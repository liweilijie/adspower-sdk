import json
import time
import uuid
import os
import sys
import psutil
import threading
import logging
from typing import Optional, Generator, List, Dict, Set
from redis import Redis
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import TimeoutException, WebDriverException
import signal
import redis
import random

# è·å–å½“å‰æ–‡ä»¶çš„ç›®å½•
current_dir = os.path.dirname(os.path.abspath(__file__))

# å°†å½“å‰ç›®å½•æ·»åŠ åˆ° sys.path
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

from adspower.config import REDIS_KEYS
from adspower.utils import get_redis_client
from adspowerapi import AdsPowerAPI


logger = logging.getLogger(__name__)


def decode_bytes(obj):
    if isinstance(obj, dict):
        return {decode_bytes(k): decode_bytes(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [decode_bytes(i) for i in obj]
    elif isinstance(obj, bytes):
        return obj.decode("utf-8")
    else:
        return obj


"""
ProfilePool ç±»åˆ†æ:

1. å•ä¾‹æ¨¡å¼çš„å¿…è¦æ€§:
   - ProfilePool ç®¡ç†ç€å…¨å±€çš„ profile èµ„æºæ± ,éœ€è¦ä¿è¯æ‰€æœ‰å®ä¾‹å…±äº«åŒä¸€ä¸ªèµ„æºæ± 
   - é¿å…å¤šä¸ªå®ä¾‹å¯¼è‡´çš„èµ„æºç«äº‰å’Œæ•°æ®ä¸ä¸€è‡´
   - ç¡®ä¿è®¡æ•°å™¨(count_key)çš„å‡†ç¡®æ€§
   - ä¿è¯æ¸…ç†ä»»åŠ¡ä¸ä¼šé‡å¤æ‰§è¡Œ

2. æ ¸å¿ƒèŒè´£:
   - ç®¡ç† profile ç”Ÿå‘½å‘¨æœŸ(åˆ›å»ºã€åˆ†é…ã€é‡Šæ”¾ã€åˆ é™¤)
   - ç»´æŠ¤ profile ä½¿ç”¨çŠ¶æ€
   - å¤„ç†è¿›ç¨‹å¿ƒè·³æ£€æµ‹
   - æ‰§è¡Œèµ„æºæ¸…ç†(è¢«å° profileã€æ­»è¿›ç¨‹èµ„æºç­‰)
   - æ§åˆ¶èµ„æºæ± å¤§å°

3. å…³é”®è®¾è®¡:
   - ä½¿ç”¨ Redis å­˜å‚¨æ‰€æœ‰çŠ¶æ€,æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²
   - é€šè¿‡å¿ƒè·³æœºåˆ¶æ£€æµ‹è¿›ç¨‹å­˜æ´»
   - å®ç°ç§Ÿçº¦æœºåˆ¶ç®¡ç† profile åˆ†é…
   - æ”¯æŒ profile å¤ç”¨å’ŒåŠ¨æ€æ‰©ç¼©å®¹
   - è‡ªåŠ¨æ¸…ç†æ— æ•ˆèµ„æº

4. çº¿ç¨‹å®‰å…¨:
   - ä½¿ç”¨ threading.Lock ä¿æŠ¤å•ä¾‹åˆ›å»º
   - Redis æ“ä½œåŸå­æ€§ä¿è¯å¹¶å‘å®‰å…¨
   - çŠ¶æ€æ›´æ–°é€šè¿‡äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§

5. å¯é æ€§ä¿è¯:
   - å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•
   - è¶…æ—¶æ§åˆ¶å’Œé‡è¯•æœºåˆ¶
   - èµ„æºæ³„éœ²é˜²æŠ¤
"""

class ProfilePool:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls, *args, **kwargs):
        """ç¡®ä¿ProfilePoolä¸ºå•ä¾‹"""
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance
    
    def __init__(self, api: 'AdsPowerAPI', redis: Redis, 
                 max_pool_size: int = 15,
                 idle_timeout: int = 300,
                 heartbeat_timeout: int = 60):  # ç§»é™¤äº† check_interval å‚æ•°
        # é˜²æ­¢é‡å¤åˆå§‹åŒ–
        if hasattr(self, '_initialized'):
            return
            
        self.api = api
        self.redis = redis
        self.max_pool_size = max_pool_size
        self.pool_key = "adspower:profile_pool"
        self.count_key = "adspower:profile_count"
        self.heartbeat_key = "adspower:process_heartbeat"
        self.idle_timeout = idle_timeout
        self.heartbeat_timeout = heartbeat_timeout
        self._initialized = True
        
        self._init_pool_count()
        # ç§»é™¤äº† _start_cleanup_thread è°ƒç”¨

    def _init_pool_count(self):
        """åˆå§‹åŒ–profileè®¡æ•°"""
        if not self.redis.exists(self.count_key):
            # è·å–å½“å‰æ‰€æœ‰profileæ•°é‡å¹¶è®¾ç½®
            profiles = self.get_all_profiles()
            self.redis.set(self.count_key, len(profiles))

    def _increment_pool_count(self):
        """å¢åŠ profileè®¡æ•°"""
        return self.redis.incr(self.count_key)

    def _decrement_pool_count(self):
        """å‡å°‘ profile è®¡æ•°"""
        try:
            # è·å–å½“å‰è®¡æ•°
            current_count = self.redis.get(self.count_key)
            if current_count is None:
                # å¦‚æœè®¡æ•°ä¸å­˜åœ¨ï¼Œé‡æ–°è®¡ç®—
                current_count = self.redis.hlen(self.pool_key)
                self.redis.set(self.count_key, current_count)
            else:
                # ç¡®ä¿è½¬æ¢ä¸ºæ•´æ•°
                current_count = int(current_count)
                # å‡å°‘è®¡æ•°ï¼Œä½†ä¸èƒ½å°äº0
                new_count = max(0, current_count - 1)
                self.redis.set(self.count_key, new_count)
            
            logger.info(f"Profile è®¡æ•°æ›´æ–°ä¸º: {new_count if 'new_count' in locals() else current_count}")
            
        except Exception as e:
            logger.error(f"æ›´æ–° profile è®¡æ•°å¤±è´¥: {e}")
            # é‡æ–°åŒæ­¥è®¡æ•°
            try:
                actual_count = self.redis.hlen(self.pool_key)
                self.redis.set(self.count_key, actual_count)
                logger.info(f"å·²é‡æ–°åŒæ­¥ profile è®¡æ•°: {actual_count}")
            except Exception as sync_error:
                logger.error(f"åŒæ­¥ profile è®¡æ•°å¤±è´¥: {sync_error}")

    def _get_pool_count(self) -> int:
        """è·å–å½“å‰ profile æ€»æ•°"""
        try:
            count = self.redis.get(self.count_key)
            if count is None:
                # å¦‚æœè®¡æ•°ä¸å­˜åœ¨ï¼Œé‡æ–°è®¡ç®—
                count = self.redis.hlen(self.pool_key)
                self.redis.set(self.count_key, count)
            return int(count)
        except Exception as e:
            logger.error(f"è·å– profile è®¡æ•°å¤±è´¥: {e}")
            # å‘ç”Ÿé”™è¯¯æ—¶ï¼Œè¿”å›å®é™…çš„å“ˆå¸Œè¡¨é•¿åº¦
            return self.redis.hlen(self.pool_key)


    def _is_process_alive(self, pid: int) -> bool:
            """æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»"""
            try:
                return psutil.pid_exists(pid)
            except Exception as e:
                logger.warning(f"æ— æ³•æ£€æµ‹PID {pid} æ˜¯å¦å­˜æ´»: {e}")
                return False

    def get_all_profiles(self) -> List[Dict]:
        """
        è·å–æ‰€æœ‰profileä¿¡æ¯
        
        Returns:
            List[Dict]: profileåˆ—è¡¨ï¼Œæ¯ä¸ªprofileåŒ…å«å®Œæ•´çš„ä¿¡æ¯
        """
        try:
            # è·å–æ‰€æœ‰profileæ•°æ®
            all_profiles = self.redis.hgetall(self.pool_key)
            
            # è§£ç å¹¶è½¬æ¢ä¸ºå­—å…¸åˆ—è¡¨
            profiles = []
            for user_id, profile_data in all_profiles.items():
                try:
                    # ç¡®ä¿user_idæ˜¯å­—ç¬¦ä¸²
                    user_id = decode_bytes(user_id)
                    # è§£æprofileæ•°æ®
                    profile = json.loads(decode_bytes(profile_data))
                    # ç¡®ä¿user_idå­˜åœ¨äºprofileä¸­
                    profile["user_id"] = user_id
                    profiles.append(profile)
                except json.JSONDecodeError as e:
                    logger.error(f"è§£æprofileæ•°æ®å¤±è´¥ {user_id}: {e}")
                except Exception as e:
                    logger.error(f"å¤„ç†profile {user_id} æ—¶å‡ºé”™: {e}")
                    
            return profiles
            
        except Exception as e:
            logger.error(f"è·å–profileåˆ—è¡¨å¤±è´¥: {e}")
            return []

    def _sync_with_adspower(self) -> None:
        """
        åŒæ­¥Redisæ•°æ®ä¸AdsPowerå®é™…çŠ¶æ€
        """
        try:
            # è·å–AdsPowerä¸­çš„æ‰€æœ‰profile
            actual_profiles = self.api.get_browser_list()
            actual_profile_ids = {p["user_id"] for p in actual_profiles}
            logger.info(f"AdsPowerä¸­çš„æ‰€æœ‰profile: {actual_profile_ids}")
            
            # è·å–Redisä¸­çš„æ‰€æœ‰profile
            redis_profiles = self.get_all_profiles()
            redis_profile_ids = {p["user_id"] for p in redis_profiles}
            logger.info(f"Redisä¸­çš„æ‰€æœ‰profile: {redis_profile_ids}")
            
            # å¦‚æœæ•°æ®å®Œå…¨ä¸€è‡´ä¸”æ²¡æœ‰å¼‚å¸¸çŠ¶æ€ï¼Œä¸éœ€è¦åŒæ­¥
            if (actual_profile_ids == redis_profile_ids and 
                all(self._verify_profile_data(p) for p in redis_profiles)):
                logger.info("Redisæ•°æ®ä¸AdsPowerä¸€è‡´ï¼Œæ— éœ€åŒæ­¥")
                return
                
            # è·å–å½“å‰æ‰“å¼€çš„æµè§ˆå™¨
            opened_browsers = self.api.get_opened_user_ids()
            logger.info(f"å½“å‰æ‰“å¼€çš„æµè§ˆå™¨: {opened_browsers}")
            
            # 1. åˆ é™¤Redisä¸­ä¸å­˜åœ¨çš„profile
            for profile in redis_profiles:
                if profile["user_id"] not in actual_profile_ids:
                    logger.warning(f"åˆ é™¤ä¸å­˜åœ¨çš„profile: {profile['user_id']}")
                    self.redis.hdel(self.pool_key, profile["user_id"])
            
            # 2. æ·»åŠ æˆ–æ›´æ–°å®é™…å­˜åœ¨çš„profile
            now = int(time.time())
            for profile in actual_profiles:
                user_id = profile["user_id"]
                profile_data = {
                    "user_id": user_id,
                    "created_at": now,
                    "last_used": now,
                    "in_use": False,
                    "is_blocked": False,
                    "blocked_count": 0,
                    "lease_id": None,
                    "spider_name": None,
                    "browser_opened": user_id in opened_browsers
                }
                
                # å¦‚æœRedisä¸­å·²å­˜åœ¨ï¼Œä¿ç•™ä¸€äº›çŠ¶æ€
                existing_data = self.redis.hget(self.pool_key, user_id)
                if existing_data:
                    try:
                        existing = json.loads(existing_data)
                        profile_data.update({
                            "created_at": existing.get("created_at", now),
                            "is_blocked": existing.get("is_blocked", False),
                            "blocked_count": existing.get("blocked_count", 0)
                        })
                    except json.JSONDecodeError:
                        logger.warning(f"è§£æprofileæ•°æ®å¤±è´¥: {user_id}")
                
                logger.debug(f"æ›´æ–°profileæ•°æ®: {profile_data}")
                self.redis.hset(self.pool_key, user_id, json.dumps(profile_data))
            
            # 3. æ›´æ–°è®¡æ•°
            actual_count = len(actual_profiles)
            self.redis.set(self.count_key, actual_count)
            
            logger.info(f"æ•°æ®åŒæ­¥å®Œæˆ: {actual_count} ä¸ªprofile")
            
        except Exception as e:
            logger.error(f"åŒæ­¥æ•°æ®å¤±è´¥: {e}")
            raise

    def _verify_profile_data(self, profile: dict) -> bool:
        """
        éªŒè¯profileæ•°æ®çš„å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§
        
        å‚æ•°:
            profile: profileæ•°æ®å­—å…¸
            
        è¿”å›:
            bool: æ•°æ®æ˜¯å¦æœ‰æ•ˆ
        """
        try:
            # æ£€æŸ¥å¿…è¦å­—æ®µ
            required_fields = {
                "user_id", "created_at", "last_used", "in_use", 
                "is_blocked", "blocked_count", "browser_opened"
            }
            if not all(field in profile for field in required_fields):
                return False
            
            # æ£€æŸ¥å­—æ®µç±»å‹
            if not isinstance(profile["user_id"], str):
                return False
            if not isinstance(profile["created_at"], int):
                return False
            if not isinstance(profile["last_used"], int):
                return False
            if not isinstance(profile["in_use"], bool):
                return False
            if not isinstance(profile["is_blocked"], bool):
                return False
            if not isinstance(profile["blocked_count"], int):
                return False
            if not isinstance(profile["browser_opened"], bool):
                return False
                
            return True
            
        except Exception:
            return False

    def cleanup_resources(self):
        try:
            self._sync_with_adspower()
            
            now = int(time.time())
            all_profiles = self.get_all_profiles()
            active_processes = self._get_active_processes()
            
            logger.info(f"å½“å‰æ´»è·ƒè¿›ç¨‹: {active_processes}")
            logger.info(f"æ‰€æœ‰profilesçŠ¶æ€: {json.dumps(all_profiles, indent=2)}")

            # è·å–æ‰€æœ‰è¿›ç¨‹å¿ƒè·³
            all_heartbeats = self.redis.hgetall(self.heartbeat_key)
            logger.info(f"æ‰€æœ‰è¿›ç¨‹å¿ƒè·³: {all_heartbeats}")
            
            for profile in all_profiles:
                user_id = profile.get("user_id")
                if not user_id:
                    continue
                    
                try:
                    in_use = profile.get("in_use")
                    browser_opened = profile.get("browser_opened", False)
                    lease_id = profile.get("lease_id", "")
                    last_used = profile.get("last_used", 0)
                    is_blocked = profile.get("is_blocked", False)
                    blocked_count = profile.get("blocked_count", 0)

                    # æ‹†è§£ PID
                    process_id = lease_id.split("_")[0] if lease_id else None

                    # æ‰“å°æ‰€æœ‰å˜é‡
                    logger.info(f"{user_id}=> in_use: {in_use}, browser_opened: {browser_opened}, process_id: {process_id}, lease_id: {lease_id}, last_used: {last_used}, is_blocked: {is_blocked}, blocked_count: {blocked_count}")

                    # ğŸ” åŒé‡åˆ¤æ–­æ˜¯å¦æ˜¯æ­»äº¡è¿›ç¨‹
                    if (in_use or browser_opened) and process_id:
                        # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦çœŸçš„å­˜åœ¨
                        if self._is_process_alive(int(process_id)):
                            logger.info(f"è¿›ç¨‹ {process_id} ä»ç„¶å­˜æ´»ï¼Œè·³è¿‡æ¸…ç†")
                            continue

                        # æ£€æŸ¥å¿ƒè·³ï¼ˆå…è®¸5åˆ†é’Ÿè¶…æ—¶ï¼‰
                        heartbeat = all_heartbeats.get(process_id)
                        if heartbeat:
                            last_heartbeat = int(heartbeat)
                            heartbeat_age = now - last_heartbeat
                            logger.info(f"è¿›ç¨‹ {process_id} æœ€åå¿ƒè·³æ—¶é—´: {last_heartbeat}, å·²ç»è¿‡å» {heartbeat_age} ç§’")
                            
                            if heartbeat_age < 300:  # 5åˆ†é’Ÿè¶…æ—¶
                                logger.info(f"è¿›ç¨‹ {process_id} å¿ƒè·³æ­£å¸¸ï¼Œè·³è¿‡æ¸…ç†")
                                continue
                            else:
                                logger.warning(f"è¿›ç¨‹ {process_id} å¿ƒè·³è¶…æ—¶ {heartbeat_age} ç§’")

                        # å†æ¬¡ç¡®è®¤ Redis ä¸­çš„ lease_id æ˜¯å¦å·²è¢«æ–°è¿›ç¨‹æ›¿æ¢
                        latest_raw = self.redis.hget(self.pool_key, user_id)
                        if latest_raw:
                            latest_data = json.loads(latest_raw)
                            if latest_data.get("lease_id") != lease_id:
                                logger.info(f"è·³è¿‡ profile {user_id} çš„æ¸…ç†ï¼Œå›  lease_id å·²æ›´æ–°")
                                continue

                        logger.warning(f"æ£€æµ‹åˆ°æ­»äº¡è¿›ç¨‹ {process_id} çš„profile: {user_id}ï¼Œå‡†å¤‡æ¸…ç†")
                        self._cleanup_profile(user_id, profile, now)
                        continue

                    # æ— è¿›ç¨‹IDä½†æµè§ˆå™¨æ‰“å¼€ï¼ˆZombieçŠ¶æ€ï¼‰
                    if not process_id and browser_opened:
                        logger.warning(f"æ£€æµ‹åˆ°æ— è¿›ç¨‹ä¿¡æ¯ä½†æµè§ˆå™¨ä»æ‰“å¼€çš„ profile: {user_id}ï¼Œå‡†å¤‡æ¸…ç†")
                        self._cleanup_profile(user_id, profile, now)
                        continue

                    # å°å·æ¸…ç†
                    if is_blocked and blocked_count >= 3:
                        logger.info(f"åˆ é™¤è¢«å°çš„ profile: {user_id}")
                        self._delete_profile(user_id)
                        continue

                    # ç©ºé—²æµè§ˆå™¨å…³é—­
                    if not in_use and browser_opened and now - last_used > self.idle_timeout:
                        logger.info(f"å…³é—­ç©ºé—²æµè§ˆå™¨: {user_id}")
                        self._close_browser(user_id, profile)

                except Exception as e:
                    logger.error(f"å¤„ç† profile {user_id} æ—¶å‡ºé”™: {e}")

        except Exception as e:
            logger.error(f"æ¸…ç†èµ„æºæ—¶å‘ç”Ÿé”™è¯¯: {e}")
            if isinstance(e, (redis.ConnectionError, redis.TimeoutError)):
                logger.critical("Redis è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ Redis æœåŠ¡çŠ¶æ€")

    def _cleanup_profile(self, user_id: str, profile: dict, now: int):
        """æ¸…ç†å•ä¸ªprofileçš„èµ„æº"""
        try:
            # å…ˆæ£€æŸ¥æµè§ˆå™¨æ˜¯å¦çœŸçš„åœ¨è¿è¡Œ
            is_active = self.api.is_browser_active(user_id)
            if is_active:
                logger.info(f"å…³é—­æµè§ˆå™¨ {user_id}")
                self.api.close_browser(user_id)
            
            # æ›´æ–°çŠ¶æ€
            profile.update({
                "in_use": False,
                "last_used": now,
                "lease_id": None,
                "spider_name": None,
                "browser_opened": False
            })
            self.redis.hset(self.pool_key, user_id, json.dumps(profile))
            logger.info(f"å·²æ¸…ç†profile {user_id} çš„çŠ¶æ€")
        except Exception as e:
            logger.error(f"æ¸…ç†profile {user_id} å¤±è´¥: {e}")

    def _delete_profile(self, user_id: str):
        """åˆ é™¤è¢«å°çš„profile"""
        try:
            self.api.delete_browser([user_id])
            self.redis.hdel(self.pool_key, user_id)
            self._decrement_pool_count()
        except Exception as e:
            logger.error(f"åˆ é™¤profileå¤±è´¥: {e}")

    def _close_browser(self, user_id: str, profile: dict):
        """å…³é—­æµè§ˆå™¨"""
        try:
            self.api.close_browser(user_id)
            profile["browser_opened"] = False
            self.redis.hset(self.pool_key, user_id, json.dumps(profile))
        except Exception as e:
            logger.warning(f"å…³é—­æµè§ˆå™¨å¤±è´¥: {e}")

    def _get_active_processes(self) -> Set[str]:
        """è·å–æ‰€æœ‰æ´»è·ƒè¿›ç¨‹çš„ID"""
        now = int(time.time())
        active_processes = set()
        
        # è·å–æ‰€æœ‰è¿›ç¨‹å¿ƒè·³
        all_heartbeats = self.redis.hgetall(self.heartbeat_key)
        logger.info(f"æ‰€æœ‰è¿›ç¨‹å¿ƒè·³: {all_heartbeats}")
        
        for pid, last_heartbeat in all_heartbeats.items():
            pid = decode_bytes(pid)
            last_heartbeat = int(decode_bytes(last_heartbeat))
            
            # æ£€æŸ¥å¿ƒè·³æ˜¯å¦è¶…æ—¶
            if now - last_heartbeat <= self.heartbeat_timeout:
                active_processes.add(pid)
                logger.debug(f"è¿›ç¨‹ {pid} æ´»è·ƒä¸­ï¼Œæœ€åå¿ƒè·³: {last_heartbeat}")
            else:
                # æ¸…ç†è¶…æ—¶çš„å¿ƒè·³è®°å½•
                logger.warning(f"è¿›ç¨‹ {pid} å¿ƒè·³è¶…æ—¶ï¼Œæœ€åå¿ƒè·³: {last_heartbeat}")
                self.redis.hdel(self.heartbeat_key, pid)
                
        return active_processes

    def update_process_heartbeat(self, process_id: str):
        """æ›´æ–°è¿›ç¨‹å¿ƒè·³"""
        logger.info(f"æ›´æ–°è¿›ç¨‹å¿ƒè·³: {process_id}={int(time.time())}")
        self.redis.hset(self.heartbeat_key, process_id, int(time.time()))

    def get_available_profile(self, spider_name: str, group_id: Optional[str] = None) -> Optional[str]:
        """
        è·å–ä¸€ä¸ªå¯ç”¨çš„profile
        
        ç­–ç•¥ï¼š
        1. ä¼˜å…ˆä½¿ç”¨æœªè¢«ä½¿ç”¨çš„profile
        2. å¦‚æœæ²¡æœ‰å¯ç”¨çš„ä¸”æœªè¾¾åˆ°ä¸Šé™ï¼Œåˆ›å»ºæ–°çš„
        3. å¦‚æœè¾¾åˆ°ä¸Šé™ï¼Œç­‰å¾…ç›´åˆ°æœ‰profileå¯ç”¨
        
        Args:
            spider_name: çˆ¬è™«åç§°ï¼Œç”¨äºè·Ÿè¸ªå“ªä¸ªçˆ¬è™«åœ¨ä½¿ç”¨profile
            group_id: ç»„IDï¼Œç”¨äºåŒºåˆ†ä¸åŒçš„çˆ¬è™«ç»„
            
        Returns:
            Optional[str]: profile IDï¼Œå¦‚æœæ²¡æœ‰å¯ç”¨çš„åˆ™è¿”å›None
        """
        profiles = self.get_all_profiles()
        now = int(time.time())
        
        # å…ˆå°è¯•æ‰¾åˆ°ä¸€ä¸ªæœªè¢«ä½¿ç”¨ä¸”æœªè¢«å°ç¦çš„profile
        for profile in profiles:
            if not profile.get("in_use") and not profile.get("is_blocked"):
                user_id = profile["user_id"]
                # æ›´æ–°ä½¿ç”¨çŠ¶æ€
                profile.update({
                    "in_use": True,
                    "last_used": now,
                    "lease_id": f"{os.getpid()}_{uuid.uuid4().hex[:6]}",
                    "spider_name": spider_name,
                    "group_id": group_id
                })
                self.redis.hset(self.pool_key, user_id, json.dumps(profile))
                return user_id
        
        # å¦‚æœæ²¡æœ‰å¯ç”¨çš„ä¸”æœªè¾¾åˆ°ä¸Šé™ï¼Œåˆ›å»ºæ–°çš„
        current_count = self._get_pool_count()
        if current_count < self.max_pool_size:
            try:
                result = self.api.create_browser(group_id)
                user_id = result.get("data", {}).get("id")
                if user_id:
                    profile_data = {
                        "user_id": user_id,
                        "created_at": now,
                        "last_used": now,
                        "in_use": True,
                        "is_blocked": False,
                        "blocked_count": 0,
                        "lease_id": f"{os.getpid()}_{uuid.uuid4().hex[:6]}",
                        "spider_name": spider_name,
                        "browser_opened": False,
                        "group_id": group_id
                    }
                    self.redis.hset(self.pool_key, user_id, json.dumps(profile_data))
                    self._increment_pool_count()
                    return user_id
            except Exception as e:
                logger.error(f"åˆ›å»ºæ–°profileå¤±è´¥: {e}")
        else:
            logger.warning(f"å·²è¾¾åˆ°profileæ•°é‡ä¸Šé™({self.max_pool_size})ï¼Œç­‰å¾…å¯ç”¨profile")
        
        return None

    def mark_profile_blocked(self, user_id: str):
        """æ ‡è®°profileä¸ºè¢«å°çŠ¶æ€"""
        profile_data = self.redis.hget(self.pool_key, user_id)
        if profile_data:
            profile = json.loads(decode_bytes(profile_data))
            profile.update({
                "is_blocked": True,
                "blocked_count": profile.get("blocked_count", 0) + 1,
                "in_use": False,
                "last_used": int(time.time())
            })
            
            # åªæœ‰åœ¨è¢«å°æ¬¡æ•°è¾¾åˆ°é˜ˆå€¼æ—¶æ‰åˆ é™¤
            if profile["blocked_count"] >= 3:
                try:
                    self.api.delete_browser([user_id])
                    self.redis.hdel(self.pool_key, user_id)
                    self._decrement_pool_count()
                except Exception as e:
                    logger.error(f"åˆ é™¤è¢«å°profileå¤±è´¥: {e}")
            else:
                self.redis.hset(self.pool_key, user_id, json.dumps(profile))

    def release_profile(self, user_id: str):
        """é‡Šæ”¾profile"""
        profile_data = self.redis.hget(self.pool_key, user_id)
        if profile_data:
            profile = json.loads(decode_bytes(profile_data))
            profile.update({
                "in_use": False,
                "last_used": int(time.time()),
                "lease_id": None,
                "spider_name": None
            })
            self.redis.hset(self.pool_key, user_id, json.dumps(profile))

    def update_browser_status(self, user_id: str, is_opened: bool):
        """æ›´æ–°æµè§ˆå™¨çŠ¶æ€"""
        profile_data = self.redis.hget(self.pool_key, user_id)
        if profile_data:
            profile = json.loads(decode_bytes(profile_data))
            profile["browser_opened"] = is_opened
            self.redis.hset(self.pool_key, user_id, json.dumps(profile))

    def get_profile_info(self, user_id: str) -> Optional[Dict]:
        """è·å–profileä¿¡æ¯"""
        profile_data = self.redis.hget(self.pool_key, user_id)
        if profile_data:
            return json.loads(decode_bytes(profile_data))
        return None

    def _update_process_info(self, user_id):
        """æ›´æ–°è¿›ç¨‹ä¿¡æ¯"""
        try:
            redis_client = get_redis_client()
            current_time = int(time.time())
            process_info = {
                "pid": os.getpid(),
                "timestamp": current_time
            }
            redis_client.hset(REDIS_KEYS["process_info"], user_id, json.dumps(process_info))
            logger.info(f"æ›´æ–°è¿›ç¨‹å¿ƒè·³: {os.getpid()}={current_time}")
        except Exception as e:
            logger.error(f"æ›´æ–°è¿›ç¨‹ä¿¡æ¯å¤±è´¥: {e}")

    def _check_process_info(self, user_id):
        """æ£€æŸ¥è¿›ç¨‹ä¿¡æ¯"""
        try:
            redis_client = get_redis_client()
            process_info = redis_client.hget(REDIS_KEYS["process_info"], user_id)
            if not process_info:
                return False
            
            info = json.loads(process_info)
            pid = info.get("pid")
            
            # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»
            try:
                os.kill(pid, 0)
                return True
            except OSError:
                return False
        except Exception as e:
            logger.error(f"æ£€æŸ¥è¿›ç¨‹ä¿¡æ¯å¤±è´¥: {e}")
            return False

    def get_browser(self, **kwargs):
        """è·å–æµè§ˆå™¨å®ä¾‹"""
        try:
            if not self._current_profile:
                raise ValueError("æœªç§Ÿç”¨ profile")

            user_id = self._current_profile["user_id"]
            logger.info(f"æ­£åœ¨å¯åŠ¨æµè§ˆå™¨ï¼Œprofile: {user_id}")

            # æ›´æ–°è¿›ç¨‹ä¿¡æ¯
            self._update_process_info(user_id)

            # å¯åŠ¨æµè§ˆå™¨
            result = self.api.start_browser(user_id)
            if not result or not result.get("data"):
                raise RuntimeError(f"å¯åŠ¨æµè§ˆå™¨å¤±è´¥: {user_id}")

            # é…ç½®æµè§ˆå™¨
            self._browser = result
            browser_data = result["data"]
            selenium_addr = browser_data["ws"]["selenium"]
            webdriver_path = browser_data["webdriver"]

            # åˆ›å»ºæµè§ˆå™¨é€‰é¡¹
            chrome_options = Options()
            chrome_options.add_experimental_option("debuggerAddress", selenium_addr)

            # åˆ›å»ºæµè§ˆå™¨æœåŠ¡
            service = Service(executable_path=webdriver_path)

            # åˆ›å»ºæµè§ˆå™¨å®ä¾‹
            driver = webdriver.Chrome(service=service, options=chrome_options)

            # è®¾ç½®è¶…æ—¶
            page_load_timeout = kwargs.get('page_load_timeout', 60)
            implicit_wait = kwargs.get('implicit_wait', 10)
            driver.set_page_load_timeout(page_load_timeout)
            driver.implicitly_wait(implicit_wait)

            return driver

        except Exception as e:
            logger.error(f"è·å–æµè§ˆå™¨å¤±è´¥: {e}")
            self.release()
            raise

    def release(self):
        """é‡Šæ”¾èµ„æº"""
        try:
            if self._current_profile:
                user_id = self._current_profile["user_id"]
                logger.info(f"æ­£åœ¨é‡Šæ”¾ profile: {user_id}")

                # å…³é—­æµè§ˆå™¨
                if self._browser:
                    try:
                        self.api.close_browser(user_id)
                        logger.info(f"å…³é—­æµè§ˆå™¨ {user_id}")
                    except Exception as e:
                        logger.error(f"å…³é—­æµè§ˆå™¨å¤±è´¥: {e}")
                    finally:
                        self._browser = None

                # æ¸…ç†è¿›ç¨‹ä¿¡æ¯
                try:
                    redis_client = get_redis_client()
                    redis_client.hdel(REDIS_KEYS["process_info"], user_id)
                    logger.info(f"å·²æ¸…ç†profile {user_id} çš„çŠ¶æ€")
                except Exception as e:
                    logger.error(f"æ¸…ç†profileçŠ¶æ€å¤±è´¥: {e}")

                self._current_profile = None

        except Exception as e:
            logger.error(f"é‡Šæ”¾èµ„æºå¤±è´¥: {e}")

class AdspowerProfileLeaseManager:
    """AdsPower Profile ç§Ÿèµç®¡ç†å™¨"""

    def __init__(self, api=None, redis=None, spider_name=None, **kwargs):
        """åˆå§‹åŒ–"""
        self.api = api or AdsPowerAPI()
        self.redis = redis or get_redis_client()
        self.spider_name = spider_name
        self.heartbeat_key = REDIS_KEYS["PROCESS_HEARTBEAT"]
        self._current_profile = None
        self._browser = None

    def get_browser(self, **kwargs):
        """è·å–æµè§ˆå™¨å®ä¾‹"""
        try:
            # 1. å…ˆè·å–å¯ç”¨çš„ profile
            profile = self._get_available_profile()
            if not profile:
                raise RuntimeError("æ— æ³•è·å–å¯ç”¨çš„ profile")
            
            self._current_profile = profile
            user_id = profile["user_id"]
            
            # 2. æ ‡è®°ä¸ºä½¿ç”¨ä¸­å¹¶æ›´æ–°å¿ƒè·³
            self.update_process_heartbeat(str(os.getpid()))
            logger.info(f"æ­£åœ¨å¯åŠ¨æµè§ˆå™¨ï¼Œprofile: {user_id}")

            # 3. å¯åŠ¨æµè§ˆå™¨
            result = self.api.start_browser(user_id)
            if not result or not result.get("data"):
                raise RuntimeError(f"å¯åŠ¨æµè§ˆå™¨å¤±è´¥: {user_id}")

            # 4. é…ç½®æµè§ˆå™¨
            self._browser = result
            browser_data = result["data"]
            selenium_addr = browser_data["ws"]["selenium"]
            webdriver_path = browser_data["webdriver"]

            # 5. åˆ›å»ºæµè§ˆå™¨é€‰é¡¹
            chrome_options = Options()
            chrome_options.add_experimental_option("debuggerAddress", selenium_addr)

            # 6. åˆ›å»ºæµè§ˆå™¨æœåŠ¡
            service = Service(executable_path=webdriver_path)

            # 7. åˆ›å»ºæµè§ˆå™¨å®ä¾‹
            driver = webdriver.Chrome(service=service, options=chrome_options)

            # 8. è®¾ç½®è¶…æ—¶
            page_load_timeout = kwargs.get('page_load_timeout', 60)
            implicit_wait = kwargs.get('implicit_wait', 10)
            driver.set_page_load_timeout(page_load_timeout)
            driver.implicitly_wait(implicit_wait)

            return driver

        except Exception as e:
            logger.error(f"è·å–æµè§ˆå™¨å¤±è´¥: {e}")
            self.release()  # ç¡®ä¿èµ„æºè¢«é‡Šæ”¾
            raise

    def release(self):
        """é‡Šæ”¾èµ„æº"""
        try:
            if self._current_profile:
                user_id = self._current_profile["user_id"]
                logger.info(f"æ­£åœ¨é‡Šæ”¾ profile: {user_id}")

                # 1. å…³é—­æµè§ˆå™¨
                if self._browser:
                    try:
                        self.api.close_browser(user_id)
                        logger.info(f"å…³é—­æµè§ˆå™¨ {user_id}")
                    except Exception as e:
                        logger.error(f"å…³é—­æµè§ˆå™¨å¤±è´¥: {e}")
                    finally:
                        self._browser = None

                # 2. æ¸…ç†å¿ƒè·³ä¿¡æ¯
                try:
                    self.redis.hdel(self.heartbeat_key, str(os.getpid()))
                    logger.info(f"å·²æ¸…ç†profile {user_id} çš„çŠ¶æ€")
                except Exception as e:
                    logger.error(f"æ¸…ç†profileçŠ¶æ€å¤±è´¥: {e}")

                self._current_profile = None

        except Exception as e:
            logger.error(f"é‡Šæ”¾èµ„æºå¤±è´¥: {e}")

    def _get_available_profile(self):
        """è·å–å¯ç”¨çš„ profile"""
        try:
            # 1. è·å–æ‰€æœ‰ profiles
            result = self.api.list_profiles()
            if not result or "data" not in result or "list" not in result["data"]:
                logger.error("è·å– profiles åˆ—è¡¨å¤±è´¥")
                return None

            profiles = result["data"]["list"]
            if not profiles:
                logger.error("æ²¡æœ‰å¯ç”¨çš„ profiles")
                return None

            # 2. è·å–æ‰€æœ‰æ­£åœ¨ä½¿ç”¨çš„ profiles
            in_use_pids = self.redis.hgetall(self.heartbeat_key)
            
            # 3. è¿‡æ»¤å‡ºå¯ç”¨çš„ profiles
            available_profiles = []
            for profile in profiles:
                # æ£€æŸ¥ profile çŠ¶æ€
                if profile.get("status") != "Active":
                    continue

                # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»
                for pid_str, last_heartbeat in in_use_pids.items():
                    try:
                        pid = int(pid_str)
                        # å¦‚æœè¿›ç¨‹ä¸å­˜åœ¨ï¼Œæ¸…ç†å¿ƒè·³ä¿¡æ¯
                        try:
                            os.kill(pid, 0)
                            continue  # è¿›ç¨‹å­˜åœ¨ï¼Œç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ª
                        except OSError:
                            # è¿›ç¨‹ä¸å­˜åœ¨ï¼Œæ¸…ç†å¿ƒè·³ä¿¡æ¯
                            self.redis.hdel(self.heartbeat_key, pid_str)

                    except ValueError:
                        # pid è½¬æ¢å¤±è´¥ï¼Œæ¸…ç†æ— æ•ˆæ•°æ®
                        self.redis.hdel(self.heartbeat_key, pid_str)

                available_profiles.append(profile)

            if not available_profiles:
                logger.error("æ²¡æœ‰å¯ç”¨çš„ profiles")
                return None

            # 4. éšæœºé€‰æ‹©ä¸€ä¸ª profile
            return random.choice(available_profiles)

        except Exception as e:
            logger.error(f"è·å–å¯ç”¨ profile å¤±è´¥: {e}")
            return None

    def update_process_heartbeat(self, process_id: str):
        """æ›´æ–°è¿›ç¨‹å¿ƒè·³"""
        try:
            current_time = int(time.time())
            self.redis.hset(self.heartbeat_key, process_id, current_time)
            logger.info(f"æ›´æ–°è¿›ç¨‹å¿ƒè·³: {process_id}={current_time}")
        except Exception as e:
            logger.error(f"æ›´æ–°å¿ƒè·³å¤±è´¥: {e}")

    def mark_profile_blocked(self):
        """æ ‡è®°å½“å‰ profile ä¸ºè¢«å°ç¦"""
        try:
            if not self._current_profile:
                return

            user_id = self._current_profile["user_id"]
            logger.warning(f"æ ‡è®° profile {user_id} ä¸ºè¢«å°ç¦")
            
            # å…³é—­æµè§ˆå™¨å¹¶é‡Šæ”¾èµ„æº
            self.release()
            
            # åˆ é™¤è¿™ä¸ª profile
            try:
                self.api.delete_browser(user_id)
                logger.info(f"å·²åˆ é™¤è¢«å°ç¦çš„ profile: {user_id}")
            except Exception as e:
                logger.error(f"åˆ é™¤è¢«å°ç¦çš„ profile å¤±è´¥: {e}")

        except Exception as e:
            logger.error(f"æ ‡è®° profile è¢«å°ç¦çŠ¶æ€å¤±è´¥: {e}")

    def get_all_profiles(self) -> List[Dict]:
        """
        è·å–æ‰€æœ‰profileä¿¡æ¯
        
        Returns:
            List[Dict]: profileåˆ—è¡¨ï¼Œæ¯ä¸ªprofileåŒ…å«å®Œæ•´çš„ä¿¡æ¯
        """
        try:
            # è·å–æ‰€æœ‰profileæ•°æ®
            all_profiles = self.redis.hgetall(self.heartbeat_key)
            
            # è§£ç å¹¶è½¬æ¢ä¸ºå­—å…¸åˆ—è¡¨
            profiles = []
            for user_id, process_info in all_profiles.items():
                try:
                    # ç¡®ä¿user_idæ˜¯å­—ç¬¦ä¸²
                    user_id = decode_bytes(user_id)
                    # è§£æprocess_info
                    process_info = json.loads(decode_bytes(process_info))
                    # ç¡®ä¿user_idå­˜åœ¨äºprocess_infoä¸­
                    process_info["user_id"] = user_id
                    profiles.append(process_info)
                except json.JSONDecodeError as e:
                    logger.error(f"è§£æprocess_infoå¤±è´¥ {user_id}: {e}")
                except Exception as e:
                    logger.error(f"å¤„ç†process_info {user_id} æ—¶å‡ºé”™: {e}")
                    
            return profiles
            
        except Exception as e:
            logger.error(f"è·å–process_infoåˆ—è¡¨å¤±è´¥: {e}")
            return []
